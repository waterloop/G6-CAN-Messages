#include <stdint.h>
/**
 * @brief
 * The following is taken from https://stackoverflow.com/a/809465
 * Its Job is to validate that the size of a struct is less than or equal to
 * the maximum size of a can message's payload.
 */
#define MAX_CAN_MSG_SIZE 64
#define _impl_PASTE(a,b) a##b
#define _impl_CASSERT_LINE(predicate, line, descriptor) \
    typedef char _impl_PASTE(assertion_failed_##descriptor##_,line)[2*!!(predicate)-1];

#define VALIDATE_CAN_MESSAGE(canMessage) _impl_CASSERT_LINE((sizeof(canMessage) <= MAX_CAN_MSG_SIZE),__LINE__,canMessage)
#define PACKED_STRUCT struct __attribute__((packed))

/**
 * @brief CAN_MESSAGE The CAN_MESSAGE macro
 * is used to define can message structs. We use
 * This macro because it automatically includes a VALIDATE_CAN_MESSAGE call after defining the struct.
 * This allows us to validate at compile time that the message does not exceed the maximum size limits
 * of a single message on the can bus.
 *
 * @param commandName Command name is the name of the command associated with the message, but
 * more importantly it is the name of the struct generated by this macro
 *
 * @param fields Fields is the list of fields in order that they appear in the struct, see example
 *
 * @example The following is an example of how to use this macro for a command called "exampleCommand"
 * You'll notice that the last line of the expanded version comes from VALIDATE_CAN_MESSAGE. What it does is
 * generate a new type with a negative size if the size of the command struct is too big to be a CAN message.
 * This will cause the compiler `error: size of array <typename> is negative`. This is helpful for debugging
 * because the type name will say assertion failed, it will say the name of the type that it failed on, and
 * it will say the line number that it failed at incase the name of the type wasn't enough
 * Usage:
 * ```c
 * CAN_MESSAGE(exampleCommand, {
 *      uint8_t field1;
 *      uint8_t field2;
 *      uint8_t field3;
 *      uint8_t field4;
 *
 *      uint32_t field5;
 * });
 * ```
 *
 * Expanded Version that the compiler after preprocessing:
 * ```c
 * typedef struct __attribute__((packed))
 * {
 *      uint8_t field1;
 *      uint8_t field2;
 *      uint8_t field3;
 *      uint8_t field4;
 *
 *      uint32_t field5;
 * }
 * exampleCommand;
 * typedef char assertion_failed_exampleCommand_<line number>[2*!!(sizeof(exampleCommand) <= MAX_CAN_MESSAGE_SIZE) - 1]
 * ```
 */
#define CAN_MESSAGE(commandName, fields) \
typedef struct \
fields \
commandName; \
VALIDATE_CAN_MESSAGE(commandName);

/**
 * @brief These defines are here to make the file cpp and c compatible.
 *
 */
#ifdef __cplusplus
extern "C" {
#endif

//=========================================
//              BEGIN MESSAGES
//=========================================

CAN_MESSAGE(relayFaultDetected, {
    uint8_t errorCode;
});


#ifdef __cplusplus
}
#endif
